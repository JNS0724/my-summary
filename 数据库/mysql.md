# 数据库

## mysql关键字相关

1）limit和order by【参考：MYSQL排序的艺术：你真的懂Order By吗？】注意总结！！

2）join【参考：Mysql - JOIN详解   segmentfault】

注意，join连接查询时，**连接条件**用on，**查询条件**才用where

3）union多表联合，比较简单，主要考虑其使用的前提：1、必须由两条或多条select语句组成，并在select语句之间用union。【union All 可以重复合并】2、union中每个select必须包含相同的列、表达式或聚合函数，列的数据类型必须兼容；3、多表查询的union并不要求两个表完全相同，只需要select的字段类型相同即可。

## MYSQL的存储引擎

​1、InnoDB：mysql的默认存储引擎，支持事务、支持行锁、支持外键，默认事务隔离级别是“可重复读RR”。采用MVCC机制（一致性非锁定读）支持高并发，采用next-key-lock算法防止幻读。满足数据库四个标准的隔离级别。

​2、MyISAM：mysql5.1版本前的默认存储引擎，不支持事务和外键，默认为表级锁

区别：innoDB支持事务、行锁、外键。

## 数据库事务

### 事务的定义：让数据库从一个一致性状态转换为另一个一致性状态

### 事务的四大特性：4由锁实现，123由undo、redo日志实现

1、原子性：要么执行，要么都不执行【undoLog，回滚日志文件】

2、一致性：事务从一个一致性状态到另一个一致性状态，**完整性约束**不被破坏【由其他三个特性来保证】

3、持久性：事务对数据库的更改是持久的【redoLog，重做日志】

4、隔离性：不同事务之间不会互相干扰【锁与MVCC机制】

### 实现

​1、redo重做日志【**用于持久化**】 ：innoDB存储引擎中，redo日志的持久化需要经过redo buff --> redo file的过程。事务执行时写入buf，事务提交时写入file。也不一定，innoDB没秒都有刷buff的操作【redo日志记录的是执行过的指令？？不是，记录的是物理数据页的修改信息】

2、undo撤回日志【**用于回滚**】：undo存放在**undo段**中，位于共享表空间。回滚过程不是对数据库数据的物理修改，而是执行与事务相反的操作实现逻辑回滚。

innoDB利用redo日志和undo日志实现事务。在执行事务的sql语句时，先写undo log，再写redo log，等事务的所有sql执行完后，将redo log的内容持久化到磁盘，然后事务才commit。【相当于，在执行事务的时候，写回滚日志，写重做日志缓存。且等到所有sql执行完后，先将重写日志缓存持久化到磁盘，才commit事务。】

### 控制语句

start transaction / begin 开始事务， commit结束事务， rollback回滚事务

Savepoint identifier：创建保存点， release savepoint identifier：删除保存点

Rollback to savepoint identifier：回滚到保存点， set transaction：设置事务隔离级别

## 数据库三大范式

​    1、第一范式：字段不可再分

​    2、第二范式：必须有主键，非主键字段依赖主键

​    3、第三范式：非主键字段不能相互依赖

## 脏读、幻读、不可重复读与事务隔离级别

​    1、读未提交（read uncommitted）---脏读【读到了其他事务未提交的数据】

​    2、读可提交（read commit）：---不可重复读【读到其他事务已提交的数据】---幻读【两次读的行数不一致】

​    *3、可重复读（repeatable read）：

​    4、串行化（serializable）

**对于快照读，MYSQL通过MVCC的多版本机制来解决RR级别下的不可重复读问题和幻读问题，以及RC级别下的脏读问题；对于加锁读，行锁就能完美解决不可重复读和脏读，而MYSQL利用Next-Key Lock（行锁+间隙锁）机制，解决RR级别下的幻读问题。**

​    MYSQL的innoDB存储引擎的默认事务隔离级别是“可重复读”。对于快照读，通过MVCC机制，在本事务开始时创建快照，本事务只对这个快照进行读，因此**其他事务的修改不会影响这个快照**【其他事务的修改包括：update和insert，但是由于MVCC有版本号机制，因此其他事务的这些修改，都不会被当前事务的**这个快照**所感知】，以此来解决“**不可重复读**”和**幻读**问题；另外，对于加锁读，采用Next-Key Lock（**这种锁就是行锁+间隙锁**）解决“**幻读”**问题。【也就是说，**一致性读**的情况使用MVCC机制避免这**两个问题**，**加锁读**的情况使用**行锁避免不可重复读**，使用**间隙锁避免幻读**！！！！！】【参考：<https://zhuanlan.zhihu.com/p/103580034>】

**不可重复读和幻读的区别**，关键在于行锁的理解：删除和修改某一行是，那一行都可以持有锁，但是新增数据因为原先不存在，因此无法对原先不存在的那行提前加锁。【注意不可重复读和幻读是**同一层次**的隔离问题】

**幻读**：事务A 按照一定条件进行数据读取， 期间事务B 插入了**相同搜索条件的新数据**【插入了原先不存在的数据】，事务A再次按照原先条件进行读取时，发现了事务B 新插入的数据。【**MYSQL的解决方案：事务A读时，通过Next-Key Lock 锁住查询条件筛选出来的行，以及行之间的间隙。在事务B插入的时候，若插入的行位于被事务A的Next-Key Lock锁住的范围内时，导致阻塞。**】

**不可重复读**：如果事务A 按一定条件搜索， 期间事务B 删除了**符合条件的某一条数据**【修改或删除了原先以存在的数据】，导致事务A 再次读取时数据与原先不一致。【...现在看来这实际上也是幻读的一种，】

【幻读是指一个事物的两次查询，第二次查询读到了别的事物的新增数据。**RC隔离**级别的加锁读，**只会对存在的数据使用行锁**，对于不存在的数据不会使用间隙锁，因此别的事物可以插入数据。又因为RC级别的一致性读取每次都读最新的快照，所以能读到新插入的数据，造成幻读。mysql RR隔离级别不存在幻读问题，在**RR隔离级别**下，一致性读使用的是第一次读取数据建立的快照数据，对于别的事物提交的数据是无感知的。若果使用**加锁读**，Mysql会使用间隙锁对不满足条件且**不存在的数据**加锁，导致别的事物无法插入符合这个条件的新数据，因此也就不会产生幻读。】

**加锁读和快照读的出现场景**：参考：

51cto.com/article/700127.html  下面的场景仅对RR级别存在讨论意义，

​case1和case2：因为事务A在事务Bupdate之前先select了，【相当于事务A**先创建了快照**，】所以导致事务A的**所有select**都是**快照读**

​case3和case4：因为事务A在**第一次select之前**，事务B先update了，【相当于**事务B先加了锁**，】导致事务A对该行数据的读都升级为**加锁读**

<https://blog.csdn.net/thekenofDIS/article/details/80736401?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2.pc_relevant_paycolumn_v3&utm_relevant_index=5>

普通的select操作，就是快照读，底层实现是通过读取快照实现的，因此其他事务的update等加锁操作不影响快照读

而select for update 是加锁读，其他事务的update等加锁操作会影响这个事务的加锁读。

总结：

RR级别下，结合MVCC行多版本机制，**仅**对**普通select**操作能有效**提高读写并发效率**【这个效率提高体现在，事务A对行10进行快照读，而事务B对行10进行写，这两个事务不会因此而阻塞。】，但是对于加锁select的读写并发，以及update、delete等DML操作的写写并发并没有提高效率。

**因此，mysql数据库实际上是快照读写并发，其余情况：加锁读写、写写，都是会阻塞的，不管什么事务隔离级别下。**

【事务隔离级别、MVCC机制的效果都是为了提高普通select的并发性能】

RC级别下，由于RC本来就不是一致性的，存在不可重复读的问题，因此MVCC并不能提高RC级别下的普通select的读写并发。

因此，有RR级别+MVCC就能实现**一致性非锁定读**；而RC级别+MVCC没有效果，因为RC本来就不是一致性的。

**例子1**：select for update 的写写互斥【这里的加锁读可以替换成所有的加锁操作，**本质上这些过程都不执行MVCC机制**】

​1）事务A开启事务；事务A select for update；事务B开启事务；事务B select for update(阻塞，因为事务A已经对那一行加了写锁)

​2）继续上面的1），事务A commit，此时会唤醒事务B的加锁读继续进行【因为事务A commit后，释放了那一行的写锁】。然后，事务A 开启新事务，事务A select for update(阻塞，因为事务B的加锁读还未commit)；

​3）继续上面的2），事务B commit，则唤醒事务A的加锁读继续进行。

**例子2**：select lock in share mode的读读并发、读写互斥。

​1）事务A开启事务；事务A select lock in share mode ； 事务B开启事务；事务B select lock in share mode；两个都正常进行。【读读并发】

​2）在1）的基础上，事务B select for update（阻塞，因为事务A上了读锁，此时会阻塞事务B的写锁）；【读写互斥】

​3）在2）的基础上，事务A commit， 会唤醒事务B的加锁读。

## 数据库的锁

1、共享锁：读锁，相互不阻塞【指令：lock in share mode】

2、排他锁：写锁，会阻塞其他的写锁和读锁【指令：for update】

意向锁：参考<https://www.zhihu.com/question/51513268/answer/937543668>，意向锁是在存在行锁场景下的表锁快速失败机制。

想对行加锁，就要先对表加上同样的意向锁。而意向锁之间不互斥，意向锁只跟表级锁互斥。

因此，例如：事务A对第5行加X锁，同时会对表加IX锁。而事务B对第6行加X锁，虽然同时会对表加IX锁，但是因为**意向锁之间不互斥**，因此没有问题。

但是如果事务B对这个表加X锁，由于意向锁和表级锁互斥，这里是写写互斥，即事务B看到事务A对这个表加了IX锁，因此事务B会阻塞，直到事务A释放这个表的IX锁。也就是：意向锁是在存在行锁场景下的表锁快速失败机制。【相当于 **省了事务B加表锁时，遍历一遍是否存在其他事务加了某个行锁** 的操作】

读写互斥的同理，关键是**意向锁之间不互斥，意向锁跟表级锁互斥**。

3、表锁、行锁、间隙锁：MYSQL中按粒度的锁分类，表锁锁住整张表，实现简单、加锁快，但并发程度低；行锁锁住某一行，若表有索引则锁住索引，没有索引则创建隐藏的聚簇索引并加锁。行锁粒度小，并发程度高，加锁慢，会出现死锁；间隙锁锁住一个范围，不包含记录本身，用于防止同一事务的两次读出现幻读现象。【Next-Key-Lock算法：行锁+间隙锁】

【**innoDB对 更新操作 默认使用表锁，若更新操作使用了索引，则使用行锁**】真还是假。。。【参考下面6.4的分析，**无索引update时，加表锁**；非聚集索引update时，根据回表情况分别 对非聚集索引行 、主键行 加各自的锁；主键update时，只加一个行锁。】

间隙锁参考：<https://tech.meituan.com/2014/08/20/innodb-lock.html>

innoDB实现了读锁、写锁两种机制的**行级锁**、间隙锁。同时，innoDB支持多粒度的锁定，即意向锁。

数据库锁机制默认是悲观锁，下面的乐观、悲观和数据库无关，只是介绍锁的互斥实现。【也不是完全无关，MVCC机制可以说是使用了乐观锁思想----因为MVCC的多版本控制涉及事务的version号。】

乐观锁：数据操作时不加锁，数据提交时验证是否冲突【**需要我们自己实现**，在修改前，先查询version，相同则version+1继续执行，不相同则rollback】【CAS是原子操作？？**是的**】【innoDB讨论乐观锁没有意义，因为innoDB的MVCC机制默认就是通过version隐藏字段来实现非锁定一致性读，而这种非锁定就是乐观锁的体现------好像也不是。。。MVCC的非锁定是通过维护多个快照实现的。。】

悲观锁：修改数据前就把数据锁住，然后才进行读写，释放锁之前任何人不能操作数据。【数据库锁机制默认是悲观锁，使用时在sql语句添加相应指令（1/2中的指令）】

另外：

* 对于读操作，innoDB默认使用非锁定一致性读，即，除非在事务中手动加上了lock in share mode 或 for update，否则，默认的读操作都是非锁定一致性读。

​    非锁定一致性读是通过MVCC机制保持多个快照来实现的。对于Read Committed隔离级别，这个级别下的快照是**修改后的最新快照**，这个快照会被其他事务改变，因此其实并不满足事务的隔离性。而对于innoDB的默认隔离级别 Repeatable Read，不会读到其他事务的提交结果，因此这个快照是**事务开始时的快照**，因此，innoDB**默认情况**【快照读】下，事务之间的交替**读写不会上锁【与直接加锁的区别在于这里：在事务执行过程中的直接加写锁，会阻塞另一个读的事务，而非锁定一致性读机制会使另一个读的事务转而去读另一个快照】，也不会有事务隔离的问题**，而这是通过每次事务开始时弄一个快照，然后事务读取自己快照的信息来实现的。

​    **但innoDB也不是一直默认使用非锁定一致性读**。事务中对外键的插入和更新就是默认使用X锁、S锁，这是为了防止父子表的不一致性。

* Record Lock（行） 、 Gap Lock（间隙） 、 Next-Key-Lock（行+间隙）三种

innoDB中，对于范围查询，是使用next-key锁（对查询范围加S锁），因此其他事务对查询范围内进行更新操作（加X锁）会被阻塞。

对于单值查询，使用行锁。

* innoDB不会回滚大部分的错误异常，但是死锁除外。【所以这里其实是一种错误行为。参考innoDB技术内幕226页】

## MYSQL索引类型与慢查询优化

参考：<https://tech.meituan.com/2014/06/30/mysql-index.html>

### 为什么b+树要求把真实的数据放到叶子节点而不是内层节点

    一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。【因为数据行占很多空间】【不适用B树的原因】相对于Hash索引，B+树支持范围查找和排序操作

### 索引的最左匹配：针对于**联合索引**的情况

考虑因素：索引定义顺序、查询条件的截断位置、mysql的索引位置优化

* 首先，mysql会对能满足最左匹配条件的多个查询条件进行位置的优化，比如组合索引定义为(a,b,c)，查询条件为a=1 and c=2 and b=3，则能直接调整位置使得满足最左匹配。
* 另外，mysql会一直向右匹配，直到遇到范围查询（>、<、between、like）就停止匹配，但如果B+叶子能使用下一个索引，则继续使用，同时，能使用1）中的位置优化。例如：查询条件为a=1 and b=2 and c>10 and d=3，组合索引定义为（a,b,c,d）的话，d无法使用索引【要从B+树底层思考，因为索引定义顺序是abcd，因此B+树的叶子节点内容也是按照abcd来组建查询条件的，即，先查完a，才能查b。而这里索引定义为abcd，查询条件到c时就停止了，因此d索引无法使用，因为被c的范围查询阻断了。】；而如果组合索引定义为（a,b,d,c）则d的索引能使用【因为B+树的叶子按照abdc来组建，就算查询条件到c处被阻断了，也不影响B+树的“**下一个索引的选择**”。】【其实也可以理解为，mysql的位置优化会将查询条件按照索引定义的顺序来排。】

### 非聚集索引**回表问题**【也称为**覆盖索引**】

​由于非聚集索引的叶子节点存储的是【非聚集索引键，数据行的主键】，因此，如果这次select语句查的东西包含在非聚集索引叶子节点中，则不需要回表查聚集索引。

​例如定义了非聚集索引：key1，key2

​   1、若select key1,key2,key3 from table where key1 = 'aaa'，由于查找内容有key3，**另外，key2这个索引是单独的**，因此key2、key3的列需要从主表查，因此要回表。-

​   2、若select id, key1 from table where key1 = 'aaa'， 由于key1的叶子节点包含了id【主键】以及key1【本次非聚集索引键】，因此直接叶子节点就是要查找的内容，不需要回表。

​   若定义**联合索引**：(key1, key2)

    ​3、则select key1, key2, key3 from table where key1 = 'aaa'， **仅因为**key3的存在，所以要回表。【注意这里**1的单个非聚集索引**、和**3的联合索引**的区别。区别在于：（1）中key2也要回表；（2）中key2不用回表】

### 非聚集索引上进行update时的加锁情况：【参考：<https://blog.51cto.com/u_15155077/2716366>】

结论：当使用非聚集索引列进行数据更新时，MySQL会使用非聚集索引进行查找，对于查找到满足过滤条件的每一行索引记录：

​1、在查找到的非聚集索引记录上加锁。【加第一种锁--非聚集索引的行锁】
​2、根据非聚集索引记录上包含的聚集索引键值进行**回表查找**。【回表查询】
​3、在查找到的聚集索引记录上加锁。【加第二种锁--主键的行锁】
​4、循环1、2、3步处理下一条满足过滤条件的数据。

### 分组查询时的索引优化【参考：**MySQL查询优化：GROUP BY**  文章作者是：Resemble_】

​首先，分组查询的底层实现中，分为查找+排序，即查出所有分组字段，然后对分组的字段进行排序【注意与order by区别。groud by是对分组的字段排序，order by是对分组的内容排序】，之后再利用聚集函数对分组内的行进行操作。这里的索引优化的优化点在于：避免由于**查找所有分组字段**所需的全表扫描过程。例如，索引是B+树存储的，已经按照索引键进行排序，因此，如果需要**查找某个分组字段的所有行**，只需要找到【前一个分组 -- 当前分组 -- 后一个分组】的时候，就相当于找到了这个分组的所有行数据。

​因此，这里如果select语句能把**找到【前一个分组 -- 当前分组 -- 后一个分组】的时候，就相当于找到了这个分组的所有行数据**的这个过程优化出来，就能在查找的过程中过滤很多的查找操作。同时，排序也避免了【因为索引自带排序属性】。

​因此，索引对分组查询的优化，体现在三个点上：

* 有索引时，确定分组总数不需要全表扫描，只需要遍历分组的所有行 --- 紧凑索引【出现在，比如（c1,c2,c3）是联合索引，然后select c3 where c2 = const groud by c1,c3时，由于c2的gap**打断了联合索引数据行的排序性**，因此退化为紧凑索引，此时需要遍历分组的所有行】

* groud by 条件符合联合索引的最左匹配时，进行聚集函数（MAX,MIN）的操作只需要遍历每个分组的第一行 --- 松散索引【例如，(c1,c2,c3)是联合索引，然后select c2, MAX(c2) from table groud by c1, c2，因此此时groud by的条件满足联合索引的最左匹配，因此查找出来的分组信息是**具有排序性质**的，因此求max和min可以直接通过访问第一、最后一个元素来实现，避免了遍历分组内的所有行这个过程。】

* 索引构造的B+树自带排序属性，因此不需要对groud by 进行分组的排序

​但是关于**松散索引、紧凑索引**的触发条件，还没弄太清楚

6）分页查询的索引优化（limit关键字）

​首先，分页查询的底层原理是：limit m n 先读取前面m+n条记录，然后抛弃前m条，读取后面n条想要的记录。因此，limit越大，偏移量越大，读取的记录就越多，效率越低。

​优化思路：

​ 1、利用索引进行子查询，避免回表操作：select * from table where id >= (select id from table LIMIT 1000000, 1) LIMIT 10。【分析：子查询中，虽然limit还是很大，但是由于是顺序查找，查询id使用了主键，且不需要回表，因此速度快上加快；】

​ 2、利用join

​    1、自增列、外键列自动加索引

1、数据结构角度：

​    B+索引、hash索引

2、物理存储角度：

​    聚集索引clustered Index（主键索引）：叶子节点存储行数据

​    非聚集索引（辅助索引）：叶子节点存储的是【行的辅助索引值，聚集索引【主键】】2个，【因此，辅助索引的查找，先通过查**辅助索引的B+树**，在叶节点中给出该索引**对应的主键**，再通过主键查**聚集索引B+树**找出主键对应的**数据行**】

​ innoDB是**索引组织表**，也就是说一张表只能有一个聚集索引。定义表结构的时候，主键就是聚集索引，如果没有主键就innoDB自动生成6字节的id。而普通的索引，比如key、foreignKey都是非聚集索引。

3、业务类型：

​ 联合索引：多个列共同定义为一个索引。例如key(a,b,c)，整个是一个联合索引。

​ 覆盖索引：**覆盖索引不是一种索引，只是一种叫法**，针对于联合索引不需要回表时的查询优化。

## innoDB存储引擎的优化

参考：<https://www.jianshu.com/p/8f877191eedc>

​    1）插入缓冲【插入效率优化】

将对**非聚集索引**的插入缓冲在内存，隔段时间先合并，再一起插入。【因为非聚集索引的插入，在磁盘中是随机写【因为innoDB是索引组织表，按主键的顺序存储数据行，而非聚集索引没有顺序，因此需要随机写】，因此一个一个地写效率不高。通过插入缓冲，可以将插入**同一个页**的多个插入操作一起处理，这样减少了随机写磁盘的时间。】

​ 条件：非聚集索引，且索引不唯一【如果索引是唯一的，则innoDB为了**维护唯一性**，在每次插入的时候都要**遍历一下全表**验证是否唯一，这样本来想避免的全表离散读取就无法避免了】【索引打上unique才是唯一，默认是不唯一的】

​    2）两次写机制【一致性优化】

​ 问题原因在于：数据库数据页16K，文件系统数据页4k，所以将一个数据库的脏页写入文件系统需要**四次IO**，如果执行到第二次IO的时候数据库宕机，这时候磁盘的这16k的数据页是不完整的，且无法恢复。【文件系统一个页4k，恢复操作只能针对一个页来进行】

​ 【这里的无法恢复，是指文件系统的一个页中存在错误数据，是一种**物理意义上的错误**。而不是指无法通过redo日志来恢复。】

​ 两次写方案：正常思路：1、先将16k的数据页写到共享表空间，2、然后再将16k的数据页写入磁盘。【这样就算数据库宕机，也能从共享表空间获取最近的一份备份数据来实现恢复】

​  实际方案：1、先将脏页写入内存中2MB大的double write buffer；2、double write buffer将脏页写入共享表空间的double write文件；3、double write buffer再将脏页写入磁盘。【相当于不是按照一个数据页来写，而是先整合成2MB，然后再一起写入磁盘】

​ 3）自适应哈希【热点数据回表避免】

​ 问题原因：在B+树中通过非聚集索引查找到聚集索引后，还需要回表查行数据。

​ 优化方案：innoDB监控**热点**数据，然后自适应地对热点数据建立哈希，避免多次IO回表查找真实行数据。

## MVCC多版本并发控制

​ 1）概念解释：在MYSQL的innoDB引擎中，MVCC机制能实现**不加锁时**的读写冲突中的并发控制，即**一致性非锁定读**。

​ 2）适用场景：但是MVCC的一致性非锁定读只能在**不加锁的select操作**【称为**快照读**】中使用，对于select lock in share mode（共享锁）、select for update、update、insert、delete(排它锁)的情况，使用的是当前读，不使用MVCC机制。【即，只要当事务A**仅**使用快照读【整个事务只有select ！！！**没有其他任何的语句**！！时】，那么其他事务怎么搞，都不影响事务A的效率；但是如果事务A是使用加锁读、或者update、insert、delete，都会**取消MVCC机制**，转而使用加锁的机制】

​ 3）实现方式：实现方式与事务隔离级别有关，1）在innoDB的**读可提交**情况下，读取被锁定行的**最新一份**快照数据，该机制是通过**数据行记录**中的三个隐藏字段当中的**上一个修改指针**来跟踪。2）在**可重复读**的情况下，读取的是**事务开始时**的快照。【InnoDB默认是这个】

## MYSQL的执行计划

​ explain，但是具体的现实内容，要注意整理

id：表示select查询的序列或 操作表的顺序。id相同，执行顺序从上到下，id不同，值越大越先执行

type：表示连接类型：NULL、system、const【主键索引、唯一索引时】、eq_ref、ref【非聚集索引时】、range、index【使用了索引，但还是全索引扫描，类似于groud by的索引优化那里】、all

possible key ：表示该表上可能用到的索引

key：实际用到的索引

extra：1）using index condition：表示回表查询；2）using where， using index ：表示没有覆盖索引

## MYSQL主从复制

​ 1）master数据库将数据的变化记录在binLog中

​ 2）slave数据库定时探测master的binLog，发送变化时，请求同步。接受到的数据保存到relayLog中。

## 如何处理MYSQL的慢查询

## 索引设计的原则

1、常用于where、order by 、groud by 操作的字段建立索引

2、为区分度高的列建立索引，区分度越高，索引效率越高【比如性别的区分度就很低】

3、字符串类型的字段过长，建立前缀索引

4、联合索引，尽量实现覆盖索引

## 建表原则

​ 1）一对一：共用主键

​ 2）一对多：多的一方用**字段关联**另一边的主键【即，多的一方用冗余字段来**在逻辑上**代表少的一方的主键】

​ 3）多对多：创建中间表，维护双方的主键对应关系

## 分库分表问题

1）水平分表：因为表的行数过多，所以水平切一刀。按照主键id取模

2）垂直分表：因为表的列过多，所以垂直切一刀，将字段按照业务拆开。

## 索引失效问题

1、最左前缀匹配：按照联合索引的顺序来最左前缀匹配，跳过了中间的字段会导致**索引部分失效**

2、范围查询：范围查询会导致后续的索引失效【但是，**大于等于**就没问题。为什么？？】

3、对索引字段进行函数运算会导致索引失效【例如字符串截取函数】

4、模糊查询：仅仅是尾部模糊匹配，索引会生效；头部模糊匹配会导致索引失效

5、or查询：其中一个查询条件的字段没有索引，会导致整个查询都不走索引

## SQL优化

1、插入数据：1）批量插入；2）手动提交事务；3）按主键顺序插入

2、order by：

using filesort：表示需要在排序缓冲区中进行排序，无法通过索引直接获取排序结果

using index：表示通过有序索引顺序扫描直接返回了有序数据
