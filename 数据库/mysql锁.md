# mysql的锁

按锁的粒度分: 有行锁\表锁.

按锁的使用方式有共享锁\排他锁.

innodb主要是这几种锁:

* Record Lock：在索引记录上加锁
* Gap Lock：间隙锁
* Next-key Lock：Record Lock + Gap Lock

innodb在索引上加锁实现对一条记录的加锁,当使用一级索引查询时,只需要在主键索引上加锁,当使用二级索引时,先锁二级索引,再回表锁主键索引.

innodb还有意向锁.是在存在行锁场景下的表锁快速失败机制。意向锁之间不互斥,意向锁和表锁互斥,由innodb默认加上.

## Gap Lock

当我们使用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁;对于键值在条件范围内但并不存在的记录，InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。

间隙锁和间隙锁之间是不互斥的,只阻塞插入数据,因为间隙锁只用来解决幻读问题.

RR级别才生效,因为RC级别连可重复读都不保证,没有必要解决幻读问题(感觉是这个逻辑).

## next-key lock

gap+record,是前开后闭区间.如(5,10],最后一个加了行锁.

默认的加锁就是next-key lock锁机制,在具体sql执行的时候,会根据情况退化成间隙锁或者行锁.

索引就会有优化,比如说等值查询时只锁行锁,范围查询右边与条件不匹配时,只锁间隙锁.

普通字段查询就是全表加next-key lock

## MVCC

多版本并发控制,主要是通过undolog和readview来解决并发过程中的读写冲突.

在RC和RR级别中启用.

底层实现时undo log的版本链和readview

通过readview获得当前活跃事务,这些事务会按照事务号从小到大排序,因为事务号是递增的所以隐含了时间顺序.对于活跃事务中,最小的是up_limt_id,小于它说明已经提交,则可见.另外有一个当前事务生成时最大的事务id参数,max_limit_id.大于它说明这个事务再当前事务之后,则不可见.
当在两者范围,则看是否存在于活跃事务中,存在的话就是未提交,当前不可见.否则可见.

### 快照读

RC级别下,每次select生成一个快照

RR级别下,第一次select时,生成一个快照,后面的select复用这个快照.

在快照读下,不会有幻读问题.
