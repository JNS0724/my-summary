# mysql的锁

按锁的粒度分: 有行锁\表锁.

按锁的使用方式有共享锁\排他锁.

innodb主要是这几种锁:

* Record Lock：在索引记录上加锁
* Gap Lock：间隙锁
* Next-key Lock：Record Lock + Gap Lock

innodb在索引上加锁实现对一条记录的加锁,当使用一级索引查询时,只需要在主键索引上加锁,当使用二级索引时,先锁二级索引,再回表锁主键索引.

innodb还有意向锁.是在存在行锁场景下的表锁快速失败机制。意向锁之间不互斥,意向锁和表锁互斥,由innodb默认加上.

## Gap Lock

当我们使用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁;对于键值在条件范围内但并不存在的记录，InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。

间隙锁和间隙锁之间是不互斥的,只阻塞插入数据,因为间隙锁只用来解决幻读问题.

RR级别才生效,因为RC级别连可重复读都不保证,没有必要解决幻读问题(感觉是这个逻辑).

## next-key lock

gap+record,是前开后闭区间.如(5,10],最后一个加了行锁.

默认的加锁就是next-key lock锁机制,在具体sql执行的时候,会根据情况退化成间隙锁或者行锁.

索引就会有优化,比如说等值查询时只锁行锁,范围查询右边与条件不匹配时,只锁间隙锁.

普通字段查询就是全表加next-key lock

## MVCC

多版本并发控制,主要是通过undolog和readview来解决并发过程中的读写冲突.

在RC和RR级别中启用.

底层实现时undo log的版本链和readview

通过readview获得当前活跃事务,这些事务会按照事务号从小到大排序,因为事务号是递增的所以隐含了时间顺序.对于活跃事务中,最小的是up_limt_id,小于它说明已经提交,则可见.另外有一个当前事务生成时最大的事务id参数,max_limit_id.大于它说明这个事务再当前事务之后,则不可见.
当在两者范围,则看是否存在于活跃事务中,存在的话就是未提交,当前不可见.否则可见.

### 快照读

RC级别下,每次select生成一个快照

RR级别下,第一次select时,生成一个快照,后面的select复用这个快照.

在快照读下,不会有幻读问题.

## 死锁

死锁产生的条件：

1.互斥 只能分配给一个进程
2.禁止抢占 资源不能强制从一个进程中退出
3.持有和等待：一个进程可以在等待时持有系统资源
4.循环等待：相互等待其他进程占有的资源

预防死锁必须破坏其中的一环。

mysql造成死锁的典型：
1.交互上锁，互相等待。
2.加了同一个区域的间隙锁，导致互相等待。
3.一个从主键索引开始锁，一个在二级索引开始锁，不同的加锁顺序，导致互相等待。

尽量缩小锁的范围，确定加锁的顺序，避免死锁。

## 死锁检测

以事务为顶点，锁为边的有向图，判断有向图是否有环。

检测到死锁之后，选择插入更新或者删除的行数最少的事务回滚，基于 INFORMATION_SCHEMA.INNODB_TRX 表中的 trx_weight 字段来判断。