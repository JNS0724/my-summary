# 传输层

实现不同主机之间进程端到端的通信。

## 端口号

在IP的基础上，新增了端口号的标识，在TCP/IP协议簇中，端口号是在0到65535之间的16 位整数。

* 熟知端口。端口号的范围是0~1023，由ICANN 分配和控制。这些是熟知端口号。
* 注册端口。端口号的范围是1024~49151，ICANN 不分配也不控制。它们可在ICANN 注册以防重复。
* 动态端口。端口号的范围是49152~65535。这一范围内的端口号既不受控制又不需要注册，可以由任何进程使用。它们是临时或私有端口号。

## TCP协议

传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

![TCP首部](/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/TCP%E9%A6%96%E9%83%A8.jpg)

### TCP三次握手和四次挥手

![TCP三次握手和四次挥手](/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/assets/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg)

### TCP 握手初始序列号

TCP初始化序列号不能设置为一个固定值，因为这样容易被攻击者猜出后续序列号，从而遭到攻击。
RFC1948中提出了一个较好的初始化序列号ISN随机生成算法。
ISN = M + F(localhost, localport, remotehost, remoteport).
M是一个计时器，这个计时器每隔4毫秒加1。
F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。

### 半连接队列和全连接队列

tcp服务端创建连接时需要用两个队列，分别存储 SYN_RCVD 状态的连接和 ESTABLISHED 状态的连接，这就是半连接队列和全连接队列。

1、半连接队列有可能遇到攻击，即客户端大量发送syn但不回复服务端的syn+ack。

半连接队列的大小与三个值有关：

用户层 listen 传入的backlog

系统变量 net.ipv4.tcp_max_syn_backlog，默认值为 128

系统变量 net.core.somaxconn，默认值为 128

内核协议栈有一个优化，通过发送syn+ack和一个cookie来确认对面是不是正常用户。

2、全连接队列满了，通常发生在请求过多，来不及处理的情况。或者accept太慢了。

全连接队列的大小是 listen 传入的 backlog 和 somaxconn 中的较小值。

正常情况，从半连接队列取出连接，然后放入全连接队列。

这时全连接队列满了，如果设置了 net.ipv4.tcp_abort_on_overflow。就回复RST，删除对应半连接。否则不回复，一段时间后重发syn+ack.

全连接队列满了对于客户端来说是不感知的，所以如果客户端这时发送数据来的话，这时服务端会回复RST或者不回复。

### TIME_WAIT 状态

TIME_WAIT 仅在主动断开连接的一方出现，被动断开连接的一方会直接进入 CLOSED 状态，进入 TIME_WAIT 的客户端需要等待 2 MSL 才可以真正关闭连接。

* 防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到；
* 在默认情况下，如果客户端等待足够长的时间就会遇到以下两种情况：
服务端正常收到了 ACK 消息并关闭当前 TCP 连接；
服务端没有收到 ACK 消息，重新发送 FIN 关闭连接并等待新的 ACK 消息；
只要客户端等待 2 MSL 的时间，客户端和服务端之间的连接就会正常关闭，新创建的 TCP 连接收到影响的概率也微乎其微，保证了数据传输的可靠性。

### TCP重传机制

#### 超时重传

重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是常说的超时重传。
定时器的等待时间称为RTO（Retransmission Timeout 超时重传时间），数据从网络一端传送到另一端往返所需的时间称为RTT（Round-Trip Time 往返时延）。

* 当超时时间 RTO 较大时，一个RTT结束之后可能还要继续等待，传输效率降低。
* 当超时时间 RTO 较小时，导致多传包，会增加网络拥塞。

根据上述的两种情况，可以得知，超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。Linux 是如何计算 RTO 的呢？

* 需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。
* 除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。

如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是超时间隔加倍。
也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。

#### 快速重传

为TCP等待一定数目的重复ACK（称为重复ACK阈值或dupthresh），来决定数据是否丢失并触发快速重传。通常dupthresh为常量（值为3），但是linux系统可基于当前的失序程度动态调节该值。

对于重传的包，有两种选择

* 一种是仅重传timeout的包。
* 另一种是重传timeout后所有的数据。

#### Selective Acknowledgment (SACK)

在TCP首部增加SACK，用来标识没有收到的包序号范围。

### 拥塞控制

1. 慢启动

2. 拥塞避免

3. 快重传
    接收方收到一个失序的报文段就发出重复确认，发送方一连收到三个重复确认就重传对方未确认收到的报文段

4. 快速恢复
    发送方收到三个重复确认就把cwnd设置为ssthresh门限减半后的数值、开始执行拥塞避免。

### keepAlive

一段时间后发送探测报文，没反应则主动关闭连接。
TCP的KeepAlive机制意图在于保活、心跳，检测连接错误
HTTP协议的Keep-Alive意图在于连接复用，同一个连接上串行方式传递请求-响应数据

## UDP

### TCP和UDP的区别

1. 基于连接与无连接
2. TCP要求系统资源较多，UDP较少
3. UDP程序结构较简单
4. 流模式（TCP）与数据报模式(UDP)
5. TCP保证数据正确性，UDP可能丢包
6. TCP保证数据顺序，UDP不保证

### 总结

* UDP基于无连接，不需要握手，不需要状态机维护状态。
* UDP首部开销小，只有8个字节。
* UDP不保证可靠传输，可能会丢包，但响应速度较快。
* UDP面向报文，添加首部后直接乡下交付为IP层，既不合并，也不拆分，保留这些报文的边界。对IP层交上来UDP用户数据报，在去除首部后就原封不动地交付给上层应用进程，报文不可分割，是UDP数据报处理的最小单位。

### UDP首部

源端口: 占16位、源端口号。在需要对方回信时选用。不需要时可用全0。
目的端口: 占16位、目的端口号。这在终点交付报文时必须使用。
长度: 占16位、UDP用户数据报的长度,其最小值是8(仅有首部)。
检验和: 占16位、检测UDP用户数据报在传输中是否有错。有错就丢弃。

### UDP校验

UDP校验和的计算方法和IP数据报首部校验和的计算方法相似，都使用二进制反码运算求和再取反，但不同的是：IP数据报的校验和之检验IP数据报和首部，但UDP的校验和是把首部和数据部分一起校验。
