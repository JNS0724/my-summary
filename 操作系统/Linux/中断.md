# 操作系统中断

中断通常分为同步中断和异步中断。

* 同步
  * 来自cpu内部，当指令执行时由CPU控制单元产生的，只有在一条指令终止执行后CPU才能产生中断。
  * 在Intel微处理器手册中，又称为异常，是由程序的错误或者由内核必须处理的异常条件产生的。对于第一个错误，内核通过发送一个信号来处理异常；第二种情况下，内核执行恢复异常所需的步骤，如缺页或内核服务的请求 int sysenter系统调用指令

* 异步
  * 来自其他硬件设备的中断信号，分为可屏蔽和不可屏蔽
  * 在Intel微处理器手册中，称为中断，由间隔定时器和IO设备产生，如键盘输入。

## 中断信号

当一个中断信号达到时，cpu停止当前工作，切换到新的活动。为实现这一点，要在内核态堆栈中保存程序计数器的当前值（eip和cs），并把中断类型的地址放进程序计数器。
中断处理和进程切换的差异在于中断处理执行的代码不是一个进程，是一个内核控制路径，比内核轻量。
中断处理约束：

* 响应中断后的操作由两部分，关键的立即执行，非关键的随后执行。

* 中断处理程序必须编写成使相应的内核控制路径能以嵌套的方式运行。最后一个内核控制路径终止时，能恢复被中断进程。

* 在内核代码临界区，中断必须被禁止。

## 中断和异常

中断分为：

* 可屏蔽中断：IO设备发出的所有中断。中断位于两种状态，屏蔽的和非屏蔽的，屏蔽时，控制单元忽略它。根据中断允许标志来判断cpu是否响应。
* 非屏蔽中断：危急事件，如硬件故障。

异常分为：
取决于cpu在产生异常时保存在内核态堆栈eip寄存器的值。

* 故障 fault：可以纠正，一旦纠正就可以不失连贯性重新开始。保存在eip的是引起故障的指令地址，当异常处理程序终止，那条指令会重新执行。

* 陷阱 trap：保存在eip的是随后要执行的指令地址。主要用途是调试程序。

* 异常中止 abort：用于报告严重的错误，硬件故障或系统表无效的值或不一样的值。

* 编程异常：编程者发出请求时产生，由int和int3指令触发，程序溢出或越界。通常称为软中断，用途是执行系统调用或给调试程序报告特定的事件。

每个中断和异常由0-255的数来标识，Intel称为向量。非屏蔽中断和异常的向量时固定的，可屏蔽中断的向量可以通过对中断控制器的编程来改变。

### IRQ和PIC

硬件设备控制器通过IRQ输出线发出中断请求，IRQ线和可编程中断控制器PIC相连。
可编程中断控制器PIC执行如下动作：

1. 监视IRQ线，检查信号。
2. 将信号转为向量，存放在中断控制器的IO端口，被cpu通过数据总线读取。发送信号到INTR引脚，产生中断，等到cpu确认，清INTR线。

80x86微处理器每个cpu都含有一个本地APIC，每个APIC由32位的寄存器、一个内部时钟、一个本地定时设备及为本地APIC中断保留的两条额外IRQ线。所有本地APIC连接到外部APIC，形成多APIC系统。

### 中断请求分发

* 静态分发
    IRQ信号传递给重定向表和表相应项的本地APIC，中断传递给特定的cpu或一组、所有的cpu。

* 动态分发
    每个本地APIC都有一个可编程任务优先级寄存器，计算当前运行进程的优先级，如多个cpu共享最低优先级，通过仲裁分配。

cpu之间还可以产生处理器间中断，放在本地APIC的中断指令寄存器，通过APIC总线发送消息到目的APIC。

### 中断描述符表 IDT

系统表，和每一个中断或异常向量相联系，每一个向量在表中都有相应的中断或异常处理程序入口地址。
IDT由IDTR寄存器来寻址。
IDT包含三种类型的描述符。
![IDT包含三种类型的描述符](/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/assets/IDT%E7%9A%84%E4%B8%89%E7%A7%8D%E6%8F%8F%E8%BF%B0%E7%AC%A6.png)

* 任务门
    必须取代当前进程的TSS选择符存放在任务门中。

* 中断门
    包含段选择符和中断处理程序的段内偏移量，当控制权转移到一个适当的段时，处理器清IF标志，关闭可屏蔽中断。

* 陷阱门
    与中断门类似，但不清理IF标志。

Linux利用中断门处理中断，陷阱门处理异常。

当执行一条指令后，cpu会检查前一条指令运行时是否产生中断或异常。如果是：

1. 确定中断或异常向量i。
2. 读idtr寄存器指向的IDT表中的第i项。
3. 从gdtr寄存器获得GDT基地址，在GDT中查找，以读取IDT表项的段选择符描述的段描述符。指定了中断或异常处理程序的所在段基地址。
4. 确信中断是授权的发生源发出。比较当前特权级CPL和段描述符特权级DPL，如果CPL小于DPL，产生异常。
5. 检查是否发生特权级变化，即CPL不等于DPL。如果是，cpu必须开始使用和新的特权级相关的栈。读Tr寄存器，访问运行进程TSS段，将新特权级相关的栈段和栈指针的正确值装载至ss和esp寄存器，在新的栈保存ss和esp以前的值。
6. 如果故障已经产生，用引起异常的指令地址来装载cs和eip寄存器。在栈中保存eflags、sc和eip
7. 如果异常产生了硬件出错码，保存在栈中。
7，装载cs和eip寄存器，值为IDT表中第i项门描述符的段选择符和偏移量字段。也就是跳转到中断或异常处理程序。

### 中断和异常处理程序的嵌套执行

* 对于中断，内核控制路径可以任意嵌套，中断处理程序可以被另一个中断处理程序中断。但中断处理程序永不阻塞，不能切换进程。
* 对于异常，大多数异常发生在用户态。然而，缺页发生在内核态，缺页中断可以挂起进程，直到请求的页可用。
* 中断处理程序可以抢占中断处理程序，也可以抢占异常处理程序。但异常处理程序不能抢占中断处理程序。中断处理程序从不执行可以导致缺页的操作。
* 与异常相关的内核控制路径可以在一个cpu执行，由于进程切换转移到另一个cpu执行。

### Linux门描述符分类

* 中断门
    用户态进程不能访问，门DPL为0，所有Linux中断处理程序都通过中断门激活，全部限制在内核态。
* 系统门
    用户态可以访问，门DPL为3，可以发布into bound和int $0x80
* 系统中断门
    用户态能访问，int3。
* 陷阱门
    用户态不能访问。Linux异常处理程序都通过陷阱门来激活。
* 任务门
    用户态不能访问，Linux的Double Fault。

### IDT初始化

实模式由BIOS使用，Linux接管后，二次初始化到RAM另一个区域。

## 异常处理

### 异常处理程序结构

1. 在内核堆栈中保存大多数寄存器的内容（汇编实现）
2. 用C函数处理异常
3. ret_from_exception异常处理程序

## 中断处理

中断处理依赖于中断类型：

* IO中断
* 时钟中断
* 处理器间中断

## 信号和中断

中断机制面向的是处理器，处理器在受到中断信号时，查询中断向量表，执行中断服务程序，服务完成返回中断点。中断处理是在内核态执行的。

信号机制面向的是进程，进程之间约定好收到某个信号就做什么事情。(1)当一个进程想向另一个进程发送信号，或者(2)内核收到某些硬件中断或终端中断，有必要向进程发送信号告知有某种事件产生。进程在接收到信号的情况下，根据信号的处理设置（大部分信号可定制处理程序），去执行信号处理程序。信号处理程序是在用户态执行的。本质上，信号是一种进程间通信。

信号与中断的相似之处：

* 都是异步的通信方式
* 中断执行流，执行完服务程序就返回原来的断点
* 信号和中断都是可屏蔽的

信号与中断的区别

* 中断有优先级，而信号没有优先级，所有的信号都是平等的
* 信号处理程序在用户态下执行，而中断服务程序在内核态下执行
* 中断响应是及时的，而信号响应通常有较大的时间延迟

信号的接收与处理时机
信号是异步的，一个进程不可能等待信号的到来，也不知道信号是否会到来，何时到来。因此，信号的接收不可能是进程本身完成，而是由内核代理。当进程收到一个信号，内核就在进程的未决信号集上添加该信号。这就是信号的接收时机。相对简单。但是信号的处理时机并不是在信号被接收的时候。

内核处理一个进程收到的信号的时机是在进程从内核态返回用户态时。在一个进程在内核态下运行时，信号并不立即起作用，要等到返回用户态才处理。进程只有处理完信号才会返回用户态，进程在用户态下不会有未处理完的信号。
