# 虚拟内存

## 线性地址

MMU的工作原理：

64位Linux使用的是四级页表，首先在cr3寄存器得到页表全局目录基地址，在线性地址取一部分和基地址相加，得到页上级目录地址。依次类推，最后得到一个物理地址。

页表中存有有效位，如果有效位为0，说明物理页不在内存中，需要发起缺页中断。

## 进程内存

进程虚拟内存布局

32位: 从低地址到高地址,内核占高地址1G,进程占低地址3G.

64位:内核占高地址128T,进程占低地址128T,中间部分未定义.

![进程内存布局](/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/assets/%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png)

栈在运行时会用ebp和esp指针分别指向栈底和栈顶，如果我们访问一个地址是esp+32范围内的，内核就自动进行栈动态分配。

一整块区域都由mm_struct描述

这里的栈区域是主线程的栈大小

子线程的栈区域大小可有ulimit -s查看,默认是8M,是主线程clone线程时创建的,位于堆或者mmap区域.

* 对于heap的操作，操作系统提供了brk()函数，c运行时库提供了sbrk()函数。
* 对于mmap映射区域的操作，操作系统提供了mmap()和munmap()函数。

mmap映射区域有四种映射:

按权限分私有和共享,按功能分为匿名和文件映射.

1.私有文件映射
多个进程使用同样的物理内存页进行初始化，但是各个进程对内存文件的修改不会共享，也不会反应到物理文件中

通常用来加载动态库。

2.私有匿名映射
mmap会创建一个新的映射，各个进程不共享，这种使用主要用于分配内存(malloc分配大内存会调用mmap)。例如开辟新进程时，会为每个进程分配虚拟的地址空间，这些虚拟地址映射的物理内存空间各个进程间读的时候共享，写的时候会copy-on-write。

3.共享文件映射
多个进程通过虚拟内存技术共享同样的物理内存空间，对内存文件的修改会反应到实际物理文件中，也是进程间通信(IPC)的一种机制。

用于内存映射IO，进程间通信。

4.共享匿名映射
这种机制在进行fork的时候不会采用写时复制，父子进程完全共享同样的物理内存页，这也就实现了父子进程通信(IPC)。只能父子进程用。


这些系统调用一般开发者不直接使用,通过插件式的内存管理器来管理内存.比如ptmalloc tcmalloc
