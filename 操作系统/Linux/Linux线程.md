# Linux 线程

Linux本来是没有线程的，从进程演化出线程，主要是为了更好的支持SMP以及减小（进程/线程）上下文切换开销。

内核态线程更利于并发使用多处理器的资源，用户态线程考虑的是减少上下文切换的开销。

![linux-thread](/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/assets/thread-stack.png)

## LWP

Linux为支持线程，定义了LWP 轻量级进程，通过clone()系统调用来创建。

* LWP：从Linux2.0开始支持，通过clone创建的进程(内部也是调用了fork)，由于LWP和父进程会共享部分资源，比如地址空间，文件系统，文件句柄，信号处理函数等，所以把LWP称为轻量级进程。

* 线程组：从Linux2.6开始支持，其实就是在task_struct中增加了tgid(thread group id)字段，一般认为Linux通过这种方式支持了线程，其中进程的tgid等于自己的pid，线程的tgid等于进程的pid。

## Linux线程库

Linux线程库主要有LinuxThreads和NPTL（Native POSIX Thread Library），LinuxThreads逐渐被NPTL取代。LinuxThreads和NPTL都是1:1的调度模型，用户线程其实就是通过clone创建的LWP。

## 线程栈

在 64 位系统中，除了主线程之外，其它线程的栈默认大小为 8M，而主线程的栈则没有这个限制，因为主线程的栈可以动态增长。可以用ulimit -s查看线程栈的大小

可以设置线程栈的大小

```c
pthread_attr_setstacksize (&attr, size);
```

## 上下文切换

### 系统调用

系统调用的时候有cpu上下文的切换

* 首先，把 CPU 寄存器里原来用户态的指令位置保存起来
* 为了执行内核代码，CPU 寄存器需要更新为内核态指令的新位置，最后跳转到内核态运行内核任务。
* 系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程
* 所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。

### 进程上下文

上下文切换包括两部分：

进程地址空间切换：
页表切换 TLB刷新

处理器状态切换：
保存、恢复栈信息和寄存器信息

１．发生中断时的保存现场，将发生中断时的所有通用寄存器保存到进程的内核栈，使用struct pt_regs结构。

２．地址空间切换将进程自己的页全局目录的基地址ｐgｄ保存在ttbr0_le1中，用于ｍｍｕ的页表遍历的起始点。

### 线程上下文切换

* 前后两个线程属于不同进程。此时因为资源不共享，所以切换过程就跟进程上下文切换是一样的。
* 前后两个线程属于同一个进程。此时虚拟内存是共享的，上下文切换时，虚拟内存这些资源保持不动，只需要切换线程的私有数、寄存器等不共享的数据。
