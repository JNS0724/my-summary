# 进程

Linux系统下也成为任务（task）

## 第一个进程

Linux对进程采用了一种层次系统，每个进程都依赖于一个父进程。内核启动init程序作为第一个进程，该进程负责进一步的系统初始化操作，并显示登录提示符或图形登录界面。因此init是进程树的根，所有进程都直接或间接起源自该进程。

## 进程描述符

* task_struct，描述进程打开的文件、地址空间、挂起的信号、进程的状态。通过slab分配器分配task_struct。
过去的task_struct存放在内核栈的尾端，为了x86寄存器少的快速计算。现在用slab分配器动态生成task_struct，只需在栈底和栈顶创建thread_info。
![进程描述符](/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/assets/%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6.png)

thread_info里还有task域指向task域，他们是相互指向的关系。

* 内核通过PID来标识进程，默认最大值32768，可以通过pid_max来提高上限。

### 获得进程描述符

x86通过内核栈的栈指针计算thread_info，接着从thread_info中的task域指向获得task_struct。

* 内核栈是进程陷入内核态之后，运行的堆栈空间。地址从高到低，一般就8k，低地址存放着thread_info。

## 进程和线程的区别

进程拥有的资源：
有一段进程专用的系统堆栈空间和系统空间堆栈。
有进程描述符，用于描述进程的相关信息。
有独立的存储空间，也就是专有的用户空间，相应的又会有用户空间堆栈。

linux中，进程和线程唯一区别是有没有独立的地址空间。

## 进程状态

* 可运行状态
    正在执行或者就绪状态准备执行
* 可中断的阻塞状态
* 不可中断的阻塞状态
* 暂停状态
* 跟踪状态

![进程状态](/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/assets/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png)

## 进程家族

1.init进程

所有进程都是PID为1的init进程的后代，内核在系统启动的最后阶段启动init进程。
init进程目的：读取系统的初始化脚本，并执行其他的相关程序，最终完成系统启动的整个过程。

2.task_struct中记录父子进程

* parent指针（指向父进程）
* children子进程链表

## 进程调度

<https://segmentfault.com/a/1190000039367851?utm_source=sf-similar-article>

### 进程分类

IO密集型、cpu密集型

在调度器中往往需要对IO密集型进程进行奖励来提高其调度优先级，对CPU密集型进程进行惩罚降低其调度优先级。

### 进程优先级

根据进程的重要性，可以分为：

实时进程(Real-Time Process)
普通进程(Normal Process)

实时进程PR值范围是0~99，数值越大被调度优先级越高
普通进程PR值范围是100~139，数值越小被调度优先级越高
Nice值范围是-20~19，并不是优先级但影响PR值，一般作用在普通进程上

综合来说：

实时进程要更优先被调度，普通进程的优先级一定低于实时进程
IO密集型进程要调度频繁一些，IO密集型要少分配时间片，少吃多餐
CPU密集型可以稍微惩罚，CPU密集型可以分配长一些的时间片，少餐多吃

### Linux进程调度

#### 全局队列 linux 2.4-2.6

采用一个全局队列runqueue作为核心数据结构，具备以下特点：

多个cpu共享全局队列，并非每个cpu有单独的队列
实时进程和普通进程混合且无序存放，寻找最合适进程需要遍历
就绪进程将被添加到队列，运行结束被删除
全局队列增删进程任务时需要加锁
进程被挂到不同CPU运行，缓存利用率低

#### 多级反馈队列 2.6.0-2.6.22

实现了per-cpu-runqueue，每个CPU都有一个就绪进程任务队列
引入活跃数组active和过期数组expire，分别存储就绪进程和结束进程
采用全局优先级：实时进程0-99，普通进程100-139，数值越低优先级越高，更容易被调度
每个优先级对应一个链表，引入bitmap数组来记录140个链表中的活跃任务情况

#### sched_class

在2.6.23内核中引入scheduling class的概念，将调度器模块化，系统中可以有多种调度器，使用不同策略调度不同类型的进程：

Stop调度器（内核使用）：优先级最高的调度类，可以抢占其他所有进程，不能被其他进程抢占；
Deadline调度器（用户限期进程）：使用红黑树，把进程按照绝对截止期限进行排序，选择最小进程进行调度运行；
RT调度器（用户实时进程）：为每个优先级维护一个队列；
CFS调度器（用户普通进程）：采用完全公平调度算法，引入虚拟运行时间概念；
IDLE-Task调度器（内核使用）：每个CPU都会有一个idle线程，当没有其他进程可以调度时，调度运行idle线程；

不同调度器对应不同的调度策略，分别有六种调度策略：
SCHED_DEADLINE：使task选择Deadline调度器来调度运行
SCHED_RR：时间片轮转，进程用完时间片后加入优先级对应运行队列的尾部，把CPU让给同优先级的其他进程；
SCHED_FIFO：先进先出调度没有时间片，没有更高优先级的情况下，只能等待主动让出CPU；
SCHED_NORMAL：使task选择CFS调度器来调度运行；
SCHED_BATCH：批量处理，使task选择CFS调度器来调度运行；
SCHED_IDLE：使task以最低优先级选择CFS调度器来调度运行；

* CFS调度器：SCHED_NORMAL、SCHED_BATCH、CHED_IDLE
* RT调度器：SCHED_FIFO、SCHED_RR
* DL调度器：SCHED_DEADLINE

CFS：绝对公平，引入虚拟时间vritual runtime概念，虚拟运行时间越短，优先级越高。使用红黑树来保存，优先选择虚拟运行时间最小的进程。

当一个新的进程状态转换为可运行时，需要向可运行队列中插入一个新的节点。而这个过程本质上是向红黑树中插入新节点的过程。

这会发生在两种情况下：

* 当进程由阻塞态被唤醒
* fork()调用创建新的进程

## 进程上下文切换

Linux 内核用函数 context_switch 进行进程的上下文切换，进程上下文切换主要涉及到两部分：进程地址空间切换和处理器状态切换：

### 进程的地址空间切换

将下一个进程的 pgd 虚拟地址转化为物理地址存放在 ttbr0_el1 中(这是用户空间的页表基址寄存器)，当访问用户空间地址的时候 mmu 会通过这个寄存器来做遍历页表获得物理地址。完成了这一步，也就完成了进程的地址空间切换，确切的说是进程的虚拟地址空间切换。

### 寄存器状态切换

将下一个执行的进程的描述符加载到寄存器中。

## 进程内存分配

mmap、brk系统调用

brk是将数据段(.data)的最高地址指针_edata往高地址推；mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。
